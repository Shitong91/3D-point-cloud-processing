labelComponents()
对除了ground points之外的点进行聚类分割

思路概括
按照顺序取点云阵列中的一个点，求取该点的四个邻域点。判断该四个邻域点是否和该点属于
同一label。如果输入同一label，再以所有和该点为同一label的邻域点为中心点，再次计算他们
各自的邻域点，这样不断的向外扩展，直到不是同一类位置。

具体操作：

1. 在一个点云阵列中按顺序取出一个点

   for (size_t i = 0; i < N_SCAN; ++i)
            for (size_t j = 0; j < Horizon_SCAN; ++j)
                if (labelMat.at<int>(i,j) == 0)
                    labelComponents(i, j);  //点云分类

2. 对该点的四个相邻点进行操作

注意：不是任意一个点都可以找到四个相邻点的，这里有两种特殊情况

2.1 两种特殊情况的相邻点处理

见 取相邻四个点.jpg

1) 点云阵列的第一行和最后一行

对应sensor中的最下面的线(-15)和最上面的线(15), 比如说如果是第一行
的点，它的前一行的点不存在；最后一行的点，他们的后一行的点不存在。
所以这些点没有完整的四个邻域点。故被舍弃

2) 点云阵列的第一列和最后一列

因为sensor旋转一次360度，所以初始位置和结束位置可以被认为是相邻点
所以针对第一列的点，原则上来说是没有左邻域点的，但是我们可以认为
他们的左邻域点是最后一列的点。同理，最后一列的右邻域点是第一列的点。
这样，这些点就不用被舍弃也可以用来计算。


2.2 如果确定四个相邻点是否和该中心点为同一label呢？

这里通过判断两点之间是否具有平面特征，也就是说利用一个公式来判断中心点
和相邻点的平坦程度。如果平坦程度在某个阈值之内，则认为这两个点属于同一
label.

见 分割条件.phg

在这之后通过判断角度是否大于60度来决定是否要将这个点加入保存的队列。加入的话则假设这个点是个平面点。

3. 邻域点为中心点重复计算

对中心点操作以后，如果中心点的四个邻域点有和中心点属于同一label的，就把归于同一标签的邻域点当作中心点，再去寻找它的邻域。这样一直到停止为止。


4. 程序中可能出现的两种情况

4.1 某点已经在之前的计算中被归于某一个label，这里为了避免重复计算，使用了条件labelMat.at<int>(i,j) == 0

for (size_t i = 0; i < N_SCAN; ++i)
            for (size_t j = 0; j < Horizon_SCAN; ++j)
                if (labelMat.at<int>(i,j) == 0)
                    labelComponents(i, j);  //点云分类


该条件如果成立，则说明该点还没有被计算，因为在初始化时，所有点的label都是0

4.2 在求某点的四个邻域点时，可能这个点的某个邻域点已经在之前的计算中被算过了，这里使用了条件 if (labelMat.at<int>(thisIndX, thisIndY) != 0) continue;
也就是label为非0的点，在这里一定是之前已经被归类过的。

